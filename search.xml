<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近在学习数据结构和算法，这里总结一下学习的排序算法。 选择排序 - SelectionSort基本思路:假设有一个数组（如图所示），进行从小到大的排序。首先在整个数组范围里，找出要放在第一个位置的数，也就是最小的数：1，然后将1和现在的第一名的位置8进行换位，经过交换以后，1所处的位置就是最终排序所在的位置，这样就继续在剩下的部分找此时最小的数，也就是2，然后把2和相应的第二个位置所在的元素进行交换，此时1和2两个元素也已经是最终排好序的结果。整个过程以此类推，继续在剩下的部分中找此时最小的元素，然后进行交换位置。。。。。 代码实现： 12345678910111213141516//arr为要进行排序的数组，//n为数组的元素个数，即数组大小template&lt;typename T&gt;void selectionSort(T arr[],int n )&#123; for(int i=0;i&lt;n;i++)&#123; //寻找[i,n)区间里的最小值 int minIndex = i; //记录当前所找的最小值所处索引的位置，初始化在位置i for( int j= i+1;j&lt;n;j++)&#123; if(arr[j] &lt; arr[minIndex]) //比较j位置的元素是否小于minIndex位置的元素，如果小于则更新当前的minIndex minIndex = j; &#125; //此时已经找到了[i,n)区间里的最小值，并且记录其位置已经记录下来 swap(arr[i] , arr[minIndex]); //如果使用std标准库不行，有可能需要引入algorithm标准库 &#125;&#125; 插入排序 - InsertionSort基本思路：开始只考虑8这个元素的时候，它就已经排好序了。接着看6这个元素,接下来的步骤是把6与它前面的数组进行比较，放在合适的位置，当6与8比较时，6&lt;8，所以6在8前面位置。接着看2这个元素，2与它前面的数组进行比较，2&lt;8，所以2和8交换一次位置，2继续和6比较，2&lt;6，所以2和6交换位置，此时2在最前面的位置。接着看3这个元素，3比8小，所以交换一次位置，3又比6小，所以交换一次位置，3比2大所以不进行交换操作，3插入在2和6中间，这时前面的4个元素排序完成。以此类推。 代码实现： 1234567891011121314151617template&lt;typename T&gt;void insertionSort (T arr[] , int n)&#123; //从i=1开始，因为对插入排序来说，第0个位置不用考虑 for(int i = 1 ; i &lt; n ; i++)&#123; //寻找arr[i]合适的插入位置 for(int j = i ; j &gt; 0 ; j-- )&#123; if ( arr[j] &lt; arr[j-1] ) swap(arr[j] , arr[j-1]); else //如果arr[i]元素已经在合适的位置，则可以直接进入下一个循环 break; &#125; &#125; //下面是简化后的代码 // for(int j = i ; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1] ; j-- )&#123; // swap(arr[j] , arr[j-1]); // &#125;&#125; 插入排序和选择排序相比，如果满足了条件就有机会提前结束，所以它的排序效率理论上要比选择排序高但是实际上它的运行时间比选择排序要慢，这是因为其swap操作较多，浪费了时间，所以针对这个地方进行改进 改进代码思路:首先,对位置0处的元素不作处理。 接着，看位置1处的元素6，首先对元素6做一个副本保存起来，然后看元素6是否应该在当前位置，即让他与前面的元素进行对比，如果小于前面的元素，则当前元素位置的值赋值为前一个元素的值，前一个元素位置的值赋值为刚才保存起来的副本（即当前元素的值）。（其实这也是相当于一个交换操作，在满足前一个元素大于当前元素值的情况下，进行交换值操作） 接着，看位置2处的元素2，首先对元素2做一个副本保存起来，然后元素2与前一个元素8比较，2&lt;8，则将元素2处的值赋值为8；接着再比较位置1处的元素8与位置1处的元素6的大小，将位置1处的值赋值为元素6，接着将元素2放在第一个位置。这样就少进行了交换的操作。 接着，看元素3，首先对元素3做一个副本保存起来，然后看元素3该不该放在当前位置，发现3&lt;8，所以这个位置赋值为8；然后看3是不是该放在刚才元素8的位置，发现元素3比元素6小，所以元素6放在刚才元素8的位置；然后看元素3是不是该放在刚才元素6的位置，发现元素3比元素2大，所以元素3应该放在这个位置。 这样很多交换操作就通过赋值进行取代了，所以性能更好。 改进代码：12345678910111213//改进代码template&lt;typename T&gt;void insertionSort (T arr[] , int n)&#123; //从i=1开始 for(int i = 1 ; i &lt; n ; i++)&#123; T e = arr[i]; //用e暂存i位置的数 int j; //保存元素e应该插入的位置 for(j = i ; j &gt; 0 &amp;&amp; arr[j-1] &gt; e ; j--)&#123; arr[j] = arr[j-1]; &#125; arr[j] = e; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
