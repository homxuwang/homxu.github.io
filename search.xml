<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近在学习数据结构和算法，这里总结一下学习的排序算法。 选择排序 - SelectionSort基本思路:假设有一个数组（如图所示），进行从小到大的排序。首先在整个数组范围里，找出要放在第一个位置的数，也就是最小的数：1，然后将1和现在的第一名的位置8进行换位，经过交换以后，1所处的位置就是最终排序所在的位置，这样就继续在剩下的部分找此时最小的数，也就是2，然后把2和相应的第二个位置所在的元素进行交换，此时1和2两个元素也已经是最终排好序的结果。整个过程以此类推，继续在剩下的部分中找此时最小的元素，然后进行交换位置。。。。。 代码实现： 12345678910111213141516//arr为要进行排序的数组，//n为数组的元素个数，即数组大小template&lt;typename T&gt;void selectionSort(T arr[],int n )&#123; for(int i=0;i&lt;n;i++)&#123; //寻找[i,n)区间里的最小值 int minIndex = i; //记录当前所找的最小值所处索引的位置，初始化在位置i for( int j= i+1;j&lt;n;j++)&#123; if(arr[j] &lt; arr[minIndex]) //比较j位置的元素是否小于minIndex位置的元素，如果小于则更新当前的minIndex minIndex = j; &#125; //此时已经找到了[i,n)区间里的最小值，并且记录其位置已经记录下来 swap(arr[i] , arr[minIndex]); //如果使用std标准库不行，有可能需要引入algorithm标准库 &#125;&#125; 插入排序 - InsertionSort基本思路：开始只考虑8这个元素的时候，它就已经排好序了。接着看6这个元素,接下来的步骤是把6与它前面的数组进行比较，放在合适的位置，当6与8比较时，6&lt;8，所以6在8前面位置。接着看2这个元素，2与它前面的数组进行比较，2&lt;8，所以2和8交换一次位置，2继续和6比较，2&lt;6，所以2和6交换位置，此时2在最前面的位置。接着看3这个元素，3比8小，所以交换一次位置，3又比6小，所以交换一次位置，3比2大所以不进行交换操作，3插入在2和6中间，这时前面的4个元素排序完成。以此类推。 代码实现： 1234567891011121314151617template&lt;typename T&gt;void insertionSort (T arr[] , int n)&#123; //从i=1开始，因为对插入排序来说，第0个位置不用考虑 for(int i = 1 ; i &lt; n ; i++)&#123; //寻找arr[i]合适的插入位置 for(int j = i ; j &gt; 0 ; j-- )&#123; if ( arr[j] &lt; arr[j-1] ) swap(arr[j] , arr[j-1]); else //如果arr[i]元素已经在合适的位置，则可以直接进入下一个循环 break; &#125; &#125; //下面是简化后的代码 // for(int j = i ; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1] ; j-- )&#123; // swap(arr[j] , arr[j-1]); // &#125;&#125; 插入排序和选择排序相比，如果满足了条件就有机会提前结束，所以它的排序效率理论上要比选择排序高但是实际上它的运行时间比选择排序要慢，这是因为其swap操作较多，浪费了时间，所以针对这个地方进行改进 改进代码思路:首先,对位置0处的元素不作处理。 接着，看位置1处的元素6，首先对元素6做一个副本保存起来，然后看元素6是否应该在当前位置，即让他与前面的元素进行对比，如果小于前面的元素，则当前元素位置的值赋值为前一个元素的值，前一个元素位置的值赋值为刚才保存起来的副本（即当前元素的值）。（其实这也是相当于一个交换操作，在满足前一个元素大于当前元素值的情况下，进行交换值操作） 接着，看位置2处的元素2，首先对元素2做一个副本保存起来，然后元素2与前一个元素8比较，2&lt;8，则将元素2处的值赋值为8；接着再比较位置1处的元素8与位置1处的元素6的大小，将位置1处的值赋值为元素6，接着将元素2放在第一个位置。这样就少进行了交换的操作。 接着，看元素3，首先对元素3做一个副本保存起来，然后看元素3该不该放在当前位置，发现3&lt;8，所以这个位置赋值为8；然后看3是不是该放在刚才元素8的位置，发现元素3比元素6小，所以元素6放在刚才元素8的位置；然后看元素3是不是该放在刚才元素6的位置，发现元素3比元素2大，所以元素3应该放在这个位置。 这样很多交换操作就通过赋值进行取代了，所以性能更好。 改进代码：12345678910111213//改进代码template&lt;typename T&gt;void insertionSort (T arr[] , int n)&#123; //从i=1开始 for(int i = 1 ; i &lt; n ; i++)&#123; T e = arr[i]; //用e暂存i位置的数 int j; //保存元素e应该插入的位置 for(j = i ; j &gt; 0 &amp;&amp; arr[j-1] &gt; e ; j--)&#123; arr[j] = arr[j-1]; &#125; arr[j] = e; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-cli 目录结构笔记 及 一个简单电商项目的网页架构思路]]></title>
    <url>%2F2018%2F06%2F05%2FVue-cli-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E5%8F%8A-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BD%91%E9%A1%B5%E6%9E%B6%E6%9E%84%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[学习了vue有一小段时间，期间中断去学习了java并且补了一下数据结构的基础，有点断层。跟着视频用vue2.0做了一个电商的小项目。思路稍微清晰了一些，但是因为中途转学其他的缘故，有一些东西还是忘掉了，这里总结一下使用vue-cli搭建项目的一些经验和教训。 首先是vue-cli的目录结构，这个是基于webpack的脚手架目录： 12345678910111213141516171819202122232425262728293031.|-- build // 项目构建(webpack)相关代码| |-- build.js // 生产环境构建代码| |-- check-version.js // 检查node、npm等版本| |-- utils.js // 构建工具相关| |-- vue-loader.conf.js // css加载器配置| |-- webpack.base.conf.js // webpack基础配置| |-- webpack.dev.conf.js // webpack开发环境配置| |-- webpack.prod.conf.js // webpack生产环境配置|-- config // 项目开发环境配置| |-- dev.env.js // 开发环境变量| |-- index.js // 项目一些配置变量(包括监听变量，打包路径等)| |-- prod.env.js // 生产环境变量| |-- test.env.js // 测试环境变量|-- node_modules //存放依赖的目录|-- src // 源码目录| |-- assets // 静态资源（css文件，外部js文件）| |-- components // vue公共组件| |-- router // 路由配置| |-- App.vue // 根组件| |-- main.js // 入口文件，加载各种公共组件|-- static // 静态文件，比如一些图片，json数据等|-- test // 测试文件目录|-- .babelrc // ES6语法编译配置|-- .editorconfig // 定义代码格式|-- .gitignore // git上传需要忽略的文件格式|-- .postcssrc.js|-- README.md // 项目说明|-- index.html // 入口页面|-- package.json // 项目基本信息. 当然不同版本的项目目录或者文件大同小异，基本都包括在上面了。 接下来讲一个平时用的比较多的网页排版及vue的大体配置。在此之前先介绍几个文件： index.html一般只定义一个空的根节点，在main.js里面定义的实例将挂载在根节点下，内容都通过vue组件来填充。 App.vueApp.vue 是个根组件。一个vue文件包括template,script,style三部分。vue通常用es6来写，用export default导出。&lt;style&gt;&lt;/style&gt;默认是影响全局的，如需定义作用域只在该组件下起作用，需在标签上加scoped。如要引入外部css文件，首先需给项目安装css-loader依赖包。使用import引入，比如： 12345&lt;style&gt; import &apos;./assets/css/bootstrap.css&apos;&lt;/style&gt; main.jsmain.js是个入口文件。这里:template: &#39;&lt;App/&gt;&#39;表示用&lt;app&gt;&lt;/app&gt;替换index.html里面的&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;。这么做的目的很简单，&lt;App /&gt;他就是App.vue，template就是选择vue实例要加载哪个模板。最新的vue-cli脚手架模板现在是这个形式。App.vue是主程序，其他所有的.vue都是放在App.vue中，所以只需要加载App.vue就完全可以把其他的东西加载出来。 routerrouter目录下的index.js即是路由配置文件 router中可以设置多个路由，但是这里要先引入相应的组件，在进行设置： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//引入Vue框架import Vue from &apos;vue&apos;//引入路由依赖import Router from &apos;vue-router&apos;//引入各个页面组件import IndexPage from &apos;./components/index&apos;import DetailPage from &apos;./components/detail.vue&apos;import DetailAnaPage from &apos;./components/detail/analysis&apos;import DetailPubPage from &apos;./components/detail/publish&apos;import DetailCouPage from &apos;./components/detail/count&apos;import DetailForPage from &apos;./components/detail/forecast&apos;import OrderListPage from &apos;./components/orderList&apos;Vue.use(Router)export default new Router(&#123; mode: &apos;history&apos;, routes: [ &#123; path: &apos;/&apos;, component: IndexPage &#125;, &#123; path: &apos;/orderList&apos;, component: OrderListPage &#125;, &#123; path: &apos;/detail&apos;, component: DetailPage, redirect: &apos;detail/analysis&apos;, children: [ &#123; path: &apos;forecast&apos;, component: DetailForPage &#125;, &#123; path: &apos;analysis&apos;, component: DetailAnaPage &#125;, &#123; path: &apos;publish&apos;, component: DetailPubPage &#125;, &#123; path: &apos;count&apos;, component: DetailCouPage &#125; ] &#125; ]&#125;) 这里介绍一个基础的vue模板构建思路： App.vue如下，其中的router的配置可以参见上面的代码 当然这里只设置了简单的内容，具体的方法和数据及样式根据不同的需求进行补充即可。 当然这只是一种简单的设计思路，做项目时可以用这个做为参考，但是不要被限制。]]></content>
  </entry>
</search>
